<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSD 技术剖析 | Self-Improvement</title><meta name="author" content="Vane"><meta name="copyright" content="Vane"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="So Why SSD？R-CNN系列是用两阶段检测(proposal的生成和分类回归)，通过区域建议网络和特征提取在复杂场景下提高mAP，对小物体和密集遮盖效果比较好，不过计算量比较大，速度比较慢，对于实时性的内容无法满足 YOLO系列是单阶段检测，将图像分割为网格，每个网格直接对于(边界框坐标，置信度，列别)进行预测无需生成proposal速度有很大的提升，但是早期 YOLO 每个网格仅预测 2">
<meta property="og:type" content="article">
<meta property="og:title" content="SSD 技术剖析">
<meta property="og:url" content="http://example.com/2025/04/16/SSD%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Self-Improvement">
<meta property="og:description" content="So Why SSD？R-CNN系列是用两阶段检测(proposal的生成和分类回归)，通过区域建议网络和特征提取在复杂场景下提高mAP，对小物体和密集遮盖效果比较好，不过计算量比较大，速度比较慢，对于实时性的内容无法满足 YOLO系列是单阶段检测，将图像分割为网格，每个网格直接对于(边界框坐标，置信度，列别)进行预测无需生成proposal速度有很大的提升，但是早期 YOLO 每个网格仅预测 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang1.jpg">
<meta property="article:published_time" content="2025-04-16T08:17:25.350Z">
<meta property="article:modified_time" content="2025-04-24T14:01:13.442Z">
<meta property="article:author" content="Vane">
<meta property="article:tag" content="目标检测">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="方法分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSD 技术剖析",
  "url": "http://example.com/2025/04/16/SSD%E6%8A%80%E6%9C%AF/",
  "image": "http://example.com/img/touxiang1.jpg",
  "datePublished": "2025-04-16T08:17:25.350Z",
  "dateModified": "2025-04-24T14:01:13.442Z",
  "author": [
    {
      "@type": "Person",
      "name": "Vane",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/16/SSD%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSD 技术剖析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/transpancy.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg1.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/touxiang1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Self-Improvement</span></a><a class="nav-page-title" href="/"><span class="site-name">SSD 技术剖析</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSD 技术剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-16T08:17:25.350Z" title="发表于 2025-04-16 16:17:25">2025-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-24T14:01:13.442Z" title="更新于 2025-04-24 22:01:13">2025-04-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/">技术剖析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/null)"></div><article class="post-content" id="article-container"><h1 id="So-Why-SSD？"><a href="#So-Why-SSD？" class="headerlink" title="So Why SSD？"></a>So Why SSD？</h1><p>R-CNN系列是用两阶段检测(proposal的生成和分类回归)，通过区域建议网络和特征提取在复杂场景下提高mAP，对小物体和密集遮盖效果比较好，不过计算量比较大，速度比较慢，对于实时性的内容无法满足</p>
<p>YOLO系列是单阶段检测，将图像分割为网格，每个网格直接对于(边界框坐标，置信度，列别)进行预测无需生成proposal速度有很大的提升，但是早期 YOLO 每个网格仅预测 2-3 个边界框，且同一网格内多个物体（如重叠物体）只能由一个框负责，容易漏检。仅使用顶层特征图（语义强但分辨率低），对小物体和尺度变化大的物体泛化能力差（小物体在网格中占比小，特征提取不足）。</p>
<p><strong>SSD的改进方法</strong></p>
<p><strong>①利用卷积神经网络不同层次的特征图构建金字塔式检测结构</strong></p>
<p>对于浅层特征图(高分辨率)保留更多细节，用于检测小物体</p>
<p>对于深层特征图(低分辨率)语义信息丰富，用于检测大物体</p>
<p>通过多层次特征进行融合，对不同大小的物体检测能力显著提升</p>
<p>②<strong>锚框机制的保留</strong></p>
<p>借鉴 Faster R-CNN 的锚点设计在每个特征图的每个位置预设多个不同宽高比、尺度的锚框（默认 3 种尺度 ×3 种比例），每个锚框独立预测是否包含物体及坐标偏移。YOLO 每个网格的边界框初始形状固定（仅根据训练数据统计），而 SSD 的锚框覆盖更多物体形状，且每个位置可预测多个独立物体（不受网格限制），显著提高密集物体（如人群、交通标志）的检测成功率。</p>
<p>无需候选区域生成，直接在特征图上通过卷积完成分类和回归，计算量远低于两阶段算法。</p>
<p>SSD(the Single Shot Detector)</p>
<h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p>有两种SSD网络：SSD 300和SSD 512，用于不同处输入尺寸的图像识别，论文中主要是以SSD 300为例子进行分析</p>
<p><img src="/../blogimg/image-20250416170355150.png" alt="image-20250416170355150"></p>
<ol>
<li><p>从输入到 Conv4_3</p>
<p><strong>输入</strong>：首先是一幅尺寸为300×300×3的 RGB 图像。</p>
<p><strong>VGG16 基础卷积层</strong>：经过 VGG16 网络的前几个卷积层和池化层的处理。在 VGG16 的卷积层组中，Conv4_3 是第四个卷积组中的第三个卷积层。它的输入是经过前面的卷积和池化操作后的特征图。这些操作包括多个3×3的卷积层，步长通常为1，以及池化层2×2池化，步长为2）。通过这些操作，逐渐提取图像的特征，最终 Conv4_3 输出特征图尺寸为38×38×512。这个特征图保留了较多的细节信息，因为它处于网络较浅的层次，适合用于检测小目标。</p>
</li>
<li><p>从 Conv4_3 到 Conv5_3</p>
<p><strong>延续 VGG16 卷积组</strong>：在 VGG16 架构中，Conv5_3 是第五个卷积组中的第三个卷积层。它接收来自 Conv4_3 经过后续卷积操作后的输入，同样通过一系列3×3的卷积层（步长为1），输出特征图尺寸为19×19×512。这一层继续提取图像的特征，并且随着网络层次的加深，特征的语义信息逐渐增强。</p>
</li>
<li><p>从 Conv5_3 到 Conv6（FC6）</p>
<p><strong>改造全连接层为卷积层</strong>：在 SSD 网络中，对 VGG16 的全连接层进行改造。原 VGG16 的 FC6 被转换为 Conv6。这里采用了空洞卷积，空洞数为6，padding 也为6。通过这种方式，在增加感受野的同时，保持特征图的尺寸不变。它的输入是 Conv5_3 输出的特征图，经过 Conv6 的处理后，输出特征图尺寸为19×19×1024。</p>
</li>
<li><p>从 Conv6 到 Conv7（FC7）</p>
<p><strong>进一步卷积操作</strong>：Conv7（由原 VGG16 的 FC7 改造而来）接收 Conv6 输出的特征图，通过普通的卷积操作，输出特征图尺寸为19×19×1024。这一层进一步提取语义信息，为后续检测不同尺度的目标提供更丰富的特征表示。</p>
</li>
<li><p>从 Conv7 到 Conv8_2</p>
<p><strong>新增额外特征层</strong>：为了获取多尺度特征，SSD 在原有 VGG16 改造的基础上添加新的卷积层。Conv8_2 首先通过1×1的卷积层来降低通道数，然后再通过3×3的卷积层（步长为2）进行特征提取。它的输入是 Conv7 输出的特征图，经过这些操作后，输出特征图尺寸为10×10×512。这一层的特征图开始用于检测中等尺度的目标，因为它的分辨率适中，同时具有一定的语义信息。</p>
</li>
<li><p>从 Conv8_2 到 Conv9_2</p>
<p><strong>继续特征提取与尺寸变换</strong>：Conv9_2 同样是新增的卷积层，它的操作方式与 Conv8_2 类似。输入是 Conv8_2 输出的特征图，经过先1×1卷积降通道数，再3×3卷积（步长为适当值）的操作，输出特征图尺寸为5×5×256。这一层的特征图更侧重于检测相对较大一点的目标，因为随着特征图尺寸的减小，语义信息在进一步增强。</p>
</li>
<li><p>从 Conv9_2 到 Conv10_2</p>
<p><strong>逐步构建多尺度特征</strong>：Conv10_2 接收 Conv9_2 输出的特征图，经过类似的卷积操作，输出特征图尺寸为3×3×256。这个特征图对于检测较大目标有帮助，其特征表示已经具有较强的语义信息。</p>
</li>
<li><p>从 Conv10_2 到 Conv11_2</p>
<p><strong>最后一层多尺度特征提取</strong>：Conv11_2 是新增卷积层中的最后一层，它以 Conv10_2 输出的特征图为输入，经过卷积操作后，输出特征图尺寸为1×1×256。这一层的特征图主要用于检测大目标，其语义信息最强，但空间分辨率最低。</p>
</li>
</ol>
<p>各层操作及输出整合到 Detections 的过程</p>
<p> <strong>Conv4_3</strong> 层操作及输出：</p>
<p><strong>操作</strong>：Conv4_3 层输出特征图尺寸为38×38×512。在这一层，对于每个位置会预设4个先验框（default bounding boxes）。然后使用3×3的卷积核进行卷积操作。这个卷积核的输入通道数是512，输出通道数是4× (C + 4)，这里假设类别数C（比如C &#x3D; 20代表20个不同的目标类别），那么输出通道数就是4×(20 + 4)&#x3D;96。这样就可以将输出拆分为38×38×(4×20)用于类别预测和38×38×(4×4)用于边界框偏移预测。</p>
<p><strong>对 Detections 的贡献</strong>：这一层产生的检测框数量为38×38×4 &#x3D; 5776个。这些检测框带着类别预测分数和边界框偏移量的信息，作为一部分输入到后续的整合步骤，用于生成总的 Detections。</p>
<p> Conv7 层操作及输出：</p>
<p><strong>操作</strong>：Conv7 层的输入特征图尺寸是19×19×1024。对于每个位置预设6个先验框，使用3×3的卷积核进行卷积。这个卷积核的输入通道数是1024，输出通道数是6× (C + 4)，以C &#x3D; 20为例，输出通道数为6×(20 + 4)&#x3D;144。输出可拆分为类别预测部分和边界框偏移预测部分。</p>
<p><strong>对 Detections 的贡献</strong>：这一层产生的检测框数量为19×19×6 &#x3D; 2166个。这些检测框的信息也会被整合到总的 Detections 中。</p>
<p>  <strong>Conv8_2</strong> 层操作及输出：</p>
<p><strong>操作</strong>：输入特征图尺寸为10×10×512，同样使用3×3的卷积核，输入通道数512，输出通道数6× (C + 4)（以C &#x3D; 20为例是144）进行卷积操作，分别输出类别预测和边界框偏移预测部分。</p>
<p><strong>对 Detections 的贡献</strong>：这一层产生的检测框数量为10×10×6 &#x3D; 600个，其检测框信息也被汇总到 Detections 中。</p>
<p> <strong>Conv9_2</strong> 层操作及输出：</p>
<p><strong>操作</strong>：输入是5×5×256的特征图，采用3×3的卷积核，输入通道数256，输出通道数6× (C + 4)（以C &#x3D; 20为例是144）进行卷积，输出类别和边界框偏移预测结果。</p>
<p><strong>对 Detections 的贡献</strong>：产生的检测框数量为5×5×6 &#x3D; 150个，这些检测框信息被整合到 Detections 中。</p>
<p><strong>Conv10_2</strong> 层操作及输出： </p>
<p><strong>操作</strong>：以3×3×256的特征图为输入，使用3×3的卷积核，输入通道数256，输出通道数4× (C + 4)（以C &#x3D; 20为例是96）进行卷积，得到类别和边界框偏移预测输出。</p>
<p> <strong>对 Detections 的贡献</strong>：产生的检测框数量为3×3×4 &#x3D; 36个，这些检测框的信息也会被纳入 Detections。</p>
<p><strong>Conv11_2</strong> 层操作及输出：</p>
<p><strong>操作</strong>：输入为1×1×256的特征图，通过3×3的卷积核，输入通道数256，输出通道数4× (C + 4)（以C &#x3D; 20为例是96）进行卷积操作，输出类别和边界框偏移预测部分。</p>
<p><strong>对 Detections 的贡献</strong>：产生的检测框数量为1×1×4 &#x3D; 4个，其检测框信息也会汇总到 Detections。</p>
<p><strong>整合所有层的输出到 Detections</strong></p>
<p> <strong>计算总检测框数</strong>：将上述各层产生的检测框数量相加，即5776+2166 + 600+150+36+4 &#x3D; 8732。每个检测框都包含了类别预测分数和边界框偏移量的信息，这8732个检测框（每个类别都有这么多检测框）就构成了 Detections 部分，后续会通过非极大值抑制（Non  Maximum Suppression，NMS）来去除重复的和低置信度的检测框，以得到最终的准确检测结果。</p>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>SSD和YOLO的思想相近，都是采用一个CNN网络来进行检测，但是采用了多尺度的特征图</p>
<p><img src="/../blogimg/image-20250416201804135.png" alt="image-20250416201804135"></p>
<p><strong>（1）采用多尺度特征图用于检测</strong></p>
<p>​		所谓多尺度采用大小不同的特征图，CNN网络一般前面的特征图比较大，后面会逐渐采用stride&#x3D;2的卷积或者pool来降低特征图大小，这正如图3所示，一个比较大的特征图和一个比较小的特征图，它们都用来做检测。这样做的好处是比较大的特征图来用来检测相对较小的目标，而小的特征图负责检测大目标，如图4所示，8x8的特征图可以划分更多的单元，但是其每个单元的先验框尺度比较小。</p>
<p><img src="/../blogimg/image-20250416202550092.png" alt="image-20250416202550092"></p>
<p><strong>（2）采用卷积进行检测</strong></p>
<p>​		与Yolo最后采用全连接层不同，SSD直接采用卷积对不同的特征图来进行提取检测结果。对于形状为 m×n×p 的特征图，只需要采用 3×3×p 这样比较小的卷积核得到检测值。</p>
<p><strong>（3）设置先验框</strong></p>
<pre><code>		在YOLO检测框架中，每个网格单元负责预测多个边界框，但这些边界框的初始形状仅基于网格自身的正方形区域（即边界框的坐标偏移和尺寸调整均以网格为基准）。由于真实目标的形状、比例复杂多变（如瘦长的行人、宽扁的车辆等），YOLO需要通过大量训练数据自适应学习目标的几何特征，这对模型的泛化能力提出了较高要求。   
</code></pre>
<p>​		SSD则借鉴了Faster R-CNN中锚框（Anchor）的设计思想，在每个网格单元预先设置多个具有不同尺度和长宽比的先验框（Default Boxes）。这些先验框覆盖了目标可能出现的多种几何形态（例如预设3种尺度和3种长宽比的组合），而模型预测的边界框不再直接以网格为基准，而是以这些先验框为参考进行偏移量回归（即预测相对于先验框的位置和尺寸调整）。这种设计显著降低了训练难度——模型无需从无到学目标的绝对形状，只需学习如何在预设的多样化先验框基础上微调，从而更高效地拟合真实目标。   </p>
<p>​		以典型配置为例，每个网格单元通常设置4-6个先验框，其尺度从浅层到深层逐步增大（适配不同大小的目标），长宽比涵盖1:1、1:2、2:1等常见比例。如图所示（假设图中展示了不同先验框与目标的匹配关系），当检测猫（瘦长型）和狗（偏胖型）时，模型会自动选择与目标形状最接近的先验框作为基准进行训练，通过匹配策略将真实边界框与最优先验框关联，从而优化回归参数。这种先验框机制使SSD在保持单阶段检测高效性的同时，显著提升了对复杂形状目标的检测精度。</p>
<p><img src="/../blogimg/image-20250416203552602.png" alt="image-20250416203552602"></p>
<p>​		SSD的检测值机制与YOLO不同，其每个单元的每个先验框都会输出独立检测值，对应一个边界框，主要包含两部分内容。第一部分是类别置信度（评分），SSD将“背景”视为特殊类别，若实际检测目标有C个类别，模型需预测C+1个置信度值，其中第一个值代表边界框不含目标或属于背景的评分，后续C个值对应真实目标类别的概率。当提到“C+1个类别置信度”时，需注意其中包含背景类，真实检测的目标类别仍为C个。预测时，置信度最高的类别即为边界框所属类别，若背景类置信度最高，则判定该边界框内无有效目标。在预测过程中，置信度最高的那个类别就是边界框所属的类别，特别地，当第一个置信度值最高时，表示边界框中并不包含目标。</p>
<p>SSD 检测值的第二部分是边界框的位置信息，包含 4 个参数 $(c_x, c_y, w, h)$，分别代表边界框的中心坐标及宽高。但模型实际预测的并非边界框的绝对位置，而是其相对于先验框（Default Box）的<strong>转换值</strong>（更贴切的说法是 transformation，而非单纯的 offset，可参考 R-CNN 的处理逻辑）。</p>
<p>设先验框的坐标为 ((c_{x_p}, c_{y_p}, w_p, h_p))，对应真实边界框为 $(c_{x_g}, c_{y_g}, w_g, h_g)$，则模型预测的 $(t_{c_x}, t_{c_y}, t_w, t_h)$ 是后者相对于前者的几何转换关系：通过中心坐标的归一化偏移（相对于先验框的宽高）和宽高的对数比例来编码，使网络专注于学习相对于预设形状的微调，而非直接回归绝对坐标，从而降低训练难度并提升对不同尺度目标的适应性。</p>
<p>具体数学表达为：$ \begin{cases} t_{c_x} &#x3D; \frac{c_{x_g} - c_{x_p}}{w_p}, &amp; t_{c_y} &#x3D; \frac{c_{y_g} - c_{y_p}}{h_p} \ t_w &#x3D; \log\left(\frac{w_g}{w_p}\right), &amp; t_h &#x3D; \log\left(\frac{h_g}{h_p}\right) \end{cases} $</p>
<p>上述公式通过对中心坐标进行归一化（除以先验框的宽高）、对宽高进行对数变换，将边界框回归问题转化为对先验框的偏移量预测，这种编码方式能有效避免直接回归绝对坐标时因尺度差异导致的训练不稳定问题。</p>
<p>习惯上，我们把上述从先验框位置与对应边界框位置得到预测值的过程称作边界框的编码（encode）。而在预测阶段，我们要进行反向操作，也就是解码（decode），从预测值 $$(t_{c_x}, t_{c_y}, t_w, t_h)$$ 中算出边界框的真实位置 $$(c_{x_g}, c_{y_g}, w_g, h_g)$$ ，解码公式如下：</p>
<p>$$<br>\begin{cases}<br>c_{x_g} &#x3D; t_{c_x} \times w_p + c_{x_p}\<br>c_{y_g} &#x3D; t_{c_y} \times h_p + c_{y_p}\<br>w_g &#x3D; w_p \times \exp(t_w)\<br>h_g &#x3D; h_p \times \exp(t_h)<br>\end{cases}<br>$$</p>
<p>不过，在SSD的Caffe源码实现里存在一个技巧，即设置variance超参数来对检测值进行调整。通过布尔类型的参数 <code>variance_encoded_in_target</code> 可以控制两种模式：</p>
<ul>
<li>当 <code>variance_encoded_in_target</code> 为 <code>True</code> 时，意味着variance已经包含在预测值中，解码过程就是上述所提到的情况。</li>
<li>当 <code>variance_encoded_in_target</code> 为 <code>False</code>（大多数情况下采用这种方式，或许是因为这样训练起来更容易），就需要手动设置超参数variance，用于对 $$(t_{c_x}, t_{c_y}, t_w, t_h)$$ 的4个值进行放缩。此时，边界框的解码公式变为：</li>
</ul>
<p>$$<br>\begin{cases}<br>c_{x_g} &#x3D; (t_{c_x} \times \text{variance}<em>{c_x}) \times w_p + c</em>{x_p}\<br>c_{y_g} &#x3D; (t_{c_y} \times \text{variance}<em>{c_y}) \times h_p + c</em>{y_p}\<br>w_g &#x3D; w_p \times \exp(t_w \times \text{variance}<em>{w})\<br>h_g &#x3D; h_p \times \exp(t_h \times \text{variance}</em>{h})<br>\end{cases}<br>$$</p>
<p>综上所述，对于一个大小为 $$M \times N$$ 的特征图，其中共有 $$M \times N$$ 个单元。若每个单元设置的先验框数目记为 $$k$$ ，那么每个单元总共需要 $$(C + 1 + 4) \times k$$ 个预测值，这里的 $$C$$ 表示实际要检测的目标类别数（加上背景类别后为 $$C + 1$$ 个类别）。所有单元一共需要 $$M \times N \times (C + 1 + 4) \times k$$ 个预测值。由于SSD采用卷积操作来进行检测，所以就需要 $$M \times N \times (C + 1 + 4) \times k$$ 个卷积核来完成这个特征图的检测过程。</p>
<h1 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h1><h2 id="（1）先验框匹配"><a href="#（1）先验框匹配" class="headerlink" title="（1）先验框匹配"></a>（1）先验框匹配</h2><p>首先要确定ground truth与哪个先验框进行匹配，与之匹配的先验框对应的边界框将负责预测它</p>
</article></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Vane</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/V-Ane"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">论文精读的内容并没有打上翻译，更多的是我对这一段的总结概括和理解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#So-Why-SSD%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">So Why SSD？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">网络结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">设计理念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">训练过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%88%E9%AA%8C%E6%A1%86%E5%8C%B9%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">（1）先验框匹配</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/Hourglass%E5%AD%90%E7%BD%91%E7%BB%9C/" title="Hourglass">Hourglass</a><time datetime="2025-05-05T15:45:41.859Z" title="发表于 2025-05-05 23:45:41">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/CornerNet%E6%8A%80%E6%9C%AF/" title="CornerNet网络结构剖析">CornerNet网络结构剖析</a><time datetime="2025-05-05T12:51:07.957Z" title="发表于 2025-05-05 20:51:07">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/SSD%E6%8A%80%E6%9C%AF/" title="SSD 技术剖析">SSD 技术剖析</a><time datetime="2025-04-16T08:17:25.350Z" title="发表于 2025-04-16 16:17:25">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/13/Cascade%20RCNN%E6%8A%80%E6%9C%AF/" title="Cascade R-CNN 技术剖析">Cascade R-CNN 技术剖析</a><time datetime="2025-04-13T06:50:17.011Z" title="发表于 2025-04-13 14:50:17">2025-04-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/07/RetinaNet%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/" title="RetinaNet 代码详解(MMDetection)">RetinaNet 代码详解(MMDetection)</a><time datetime="2025-04-07T09:49:34.064Z" title="发表于 2025-04-07 17:49:34">2025-04-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>